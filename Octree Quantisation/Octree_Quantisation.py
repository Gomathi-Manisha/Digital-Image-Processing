# -*- coding: utf-8 -*-
"""Untitled29.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bKQqMQcx2Nq6dKMQav2Owu-_6fex2tNu
"""

# ============================================================
#  OCTREE COLOR QUANTIZATION - GOOGLE COLAB (FASTER VERSION)
# ============================================================

from google.colab import files
from PIL import Image
import matplotlib.pyplot as plt
from math import ceil, sqrt
import numpy as np

# -------------------------------
# Octree Node and Quantizer
# -------------------------------

class OctreeNode:
    def __init__(self, level, max_depth, quantizer):
        self.level = level
        self.max_depth = max_depth
        self.quantizer = quantizer

        self.is_leaf = (level == max_depth)

        self.pixel_count = 0
        self.red_sum = 0
        self.green_sum = 0
        self.blue_sum = 0

        # 8 children for octree
        self.children = [None] * 8

        if self.is_leaf:
            quantizer.leaves.append(self)
        else:
            quantizer.levels[level].append(self)

    def add_color(self, r, g, b):
        if self.is_leaf:
            # accumulate color
            self.red_sum += r
            self.green_sum += g
            self.blue_sum += b
            self.pixel_count += 1
        else:
            # determine child index from current bit of each channel
            index = 0
            shift = 7 - self.level
            index |= ((r >> shift) & 1) << 2
            index |= ((g >> shift) & 1) << 1
            index |= ((b >> shift) & 1) << 0

            if self.children[index] is None:
                self.children[index] = OctreeNode(
                    self.level + 1, self.max_depth, self.quantizer
                )

            self.children[index].add_color(r, g, b)


class OctreeQuantizer:
    def __init__(self, max_depth=8):
        self.max_depth = max_depth
        self.leaves = []                              # all leaf nodes
        self.levels = [[] for _ in range(max_depth)]  # internal nodes by level
        self.root = OctreeNode(0, max_depth, self)

    def add_color(self, color):
        r, g, b = color
        self.root.add_color(r, g, b)

    def build_tree(self, image):
        for color in image.getdata():
            self.add_color(color)

    def reduce(self, max_colors):
        """
        Reduce the octree so that number of leaves <= max_colors.
        Merge nodes from deepest level upwards.
        """
        for level in range(self.max_depth - 1, -1, -1):
            if len(self.leaves) <= max_colors:
                break

            nodes = self.levels[level]
            for node in nodes:
                if len(self.leaves) <= max_colors:
                    break

                if node.is_leaf:
                    continue

                red_sum = 0
                green_sum = 0
                blue_sum = 0
                pixel_count = 0

                for child in node.children:
                    if child is not None:
                        red_sum += child.red_sum
                        green_sum += child.green_sum
                        blue_sum += child.blue_sum
                        pixel_count += child.pixel_count

                        if child.is_leaf and child in self.leaves:
                            self.leaves.remove(child)

                node.red_sum = red_sum
                node.green_sum = green_sum
                node.blue_sum = blue_sum
                node.pixel_count = pixel_count
                node.children = [None] * 8
                node.is_leaf = True

                if node.pixel_count > 0 and node not in self.leaves:
                    self.leaves.append(node)

    def make_palette(self):
        palette = []
        for leaf in self.leaves:
            if leaf.pixel_count > 0:
                r = leaf.red_sum // leaf.pixel_count
                g = leaf.green_sum // leaf.pixel_count
                b = leaf.blue_sum // leaf.pixel_count
                palette.append((r, g, b))
        return palette


# -------------------------------
# Helper to display palette as grid
# -------------------------------

def display_palette(palette):
    palette_size = len(palette)
    grid_size = ceil(np.sqrt(palette_size))
    cell = 20
    img = Image.new('RGB', (grid_size * cell, grid_size * cell), (255, 255, 255))
    for idx, color in enumerate(palette):
        x = (idx % grid_size) * cell
        y = (idx // grid_size) * cell
        for i in range(cell):
            for j in range(cell):
                img.putpixel((x + i, y + j), color)
    return img


# -------------------------------
# Upload image (Colab)
# -------------------------------

print("ðŸ“ Please upload an image for Octree quantization:")
uploaded = files.upload()

# Take first uploaded file
input_path = list(uploaded.keys())[0]
print("âœ… Using image:", input_path)

# -------------------------------
# Parameters
# -------------------------------

max_colors = 32      # change to 16 / 32 / 64 / 128 / 256 etc.
max_side   = 400     # resize large images to speed up processing

# -------------------------------
# Build Octree, Quantize, Display
# -------------------------------

# Open image
img = Image.open(input_path).convert('RGB')
w, h = img.size
print(f"Original size: {w} x {h}")

# Auto-resize if image is too large
if max(w, h) > max_side:
    scale = max_side / max(w, h)
    new_w = int(w * scale)
    new_h = int(h * scale)
    img = img.resize((new_w, new_h), Image.LANCZOS)
    print(f"Resized to: {new_w} x {new_h} for faster processing")

print("ðŸ“Œ Building octree...")
quantizer = OctreeQuantizer(max_depth=8)
quantizer.build_tree(img)

print("ðŸ“Œ Reducing tree to", max_colors, "colors...")
quantizer.reduce(max_colors)
palette = quantizer.make_palette()
print("ðŸ“Œ Palette size:", len(palette))

# -------------------------------
# Quantize using NumPy (fast mapping)
# -------------------------------

print("ðŸ“Œ Mapping pixels to nearest palette color...")

# Convert image to array
img_arr = np.array(img).reshape(-1, 3).astype(np.int16)  # shape: (N, 3)

# Palette array
palette_arr = np.array(palette).astype(np.int16)         # shape: (K, 3)

# Compute squared distances to all palette colors
# result: (N, K)
dists = np.sum((img_arr[:, None, :] - palette_arr[None, :, :]) ** 2, axis=2)

# Find nearest palette index for each pixel
indices = np.argmin(dists, axis=1)

# Map pixels
mapped = palette_arr[indices].astype(np.uint8)

# Reshape back to image
out_arr = mapped.reshape(img.height, img.width, 3)
out = Image.fromarray(out_arr, mode='RGB')

# -------------------------------
# Show Original vs Quantized
# -------------------------------

plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 1)
plt.title("Original (possibly resized)")
plt.imshow(img)
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title(f"Octree Quantized ({max_colors} colors)")
plt.imshow(out)
plt.axis('off')

plt.show()

# -------------------------------
# Show palette grid
# -------------------------------

palette_img = display_palette(palette)
plt.figure(figsize=(6, 6))
plt.title("Palette")
plt.imshow(palette_img)
plt.axis('off')
plt.show()

# Optional: print palette
print("Palette colors (RGB):")
for i, color in enumerate(palette):
    print(f"{i+1}: {color}")

# Save output for report / GitHub
out.save("octree_quantized.png")
palette_img.save("octree_palette.png")
print("ðŸ’¾ Saved: octree_quantized.png and octree_palette.png")